/* eslint-disable */

import * as msApi from '../../websockets/MessageApi';
import * as wsApi from '../../websockets/WebsocketApi';
import * as wsUtils from '../../websockets/WebsocketUtils';
import * as jsonChecker from './JsonProtocolChecker';
import { initialise } from 'store/Storage';
import { OpenedLaoStore, KeyPairStore } from 'store';
import { Base64Data, Hash, Lao, PublicKey, Timestamp } from "../../model/objects";
import { getCurrentTime } from "../../websockets/WebsocketUtils";
import { ActionType, CreateLao, MessageData, ObjectType } from '../../model/network/method/message/data';
import { Channel } from '../../model/objects/Channel';
import * as b64 from 'base-64';
import { JsonRpcRequest } from '../../model/network';

const assertChai = require('chai').assert;

// real set of keys generated by tweetnacl
export const mockPublicKey = 'xjHAz+d0udy1XfHp5qugskWJVEGZETN/8DV3+ccOFSs=';
export const mockSecretKey = 'vx0b2hbxwPBQzfPu9NdlCcYmuFjhUFuIUDx6doHRCM7GMcDP53S53LVd8enmq6CyRYlUQZkRM3/wNXf5xw4VKw==';
export const mockCurrentLao = JSON.parse(`{"jsonrpc":"2.0","method":"publish","params":{"channel":"/root","message":{"data":{"object":"lao","action":"create","id":"4T3gIfBzQINCW8mc1dVtrnfNnawgJxVhrJn8BXqsEG4=","name":"sas","creation":1610730679,"organizer":"xjHAz+d0udy1XfHp5qugskWJVEGZETN/8DV3+ccOFSs=","witnesses":[]},"sender":"xjHAz+d0udy1XfHp5qugskWJVEGZETN/8DV3+ccOFSs=","signature":"7iW6kKwguoSRFo/DB37DusfOG0srcjErte4wKQnS3PHCupcYb9bQXPmOEzKNs6/Q2SqJcNqmqE6hbLGRqTezBw==","message_id":"8/Wg+RGcbDEZwH+PHPHOpcKCyhVgD+MaRj7D/KwVwPo=","witness_signatures":[]}},"id":1}`);
export const sampleCreateLaoQuery = `{"jsonrpc":"2.0","method":"publish","params":{"channel":"/root","message":{"data":"eyJvYmplY3QiOiJsYW8iLCJhY3Rpb24iOiJjcmVhdGUiLCJpZCI6InI2bWRsOWxYd2RycytZbXovQWY4M2NPVXpXMU00RTJMMm82LzdRTUdRazQ9IiwibmFtZSI6Im15IGxpbCcgTEFPIDopIiwiY3JlYXRpb24iOjE2MTA3NjI3NDcsIm9yZ2FuaXplciI6InhqSEF6K2QwdWR5MVhmSHA1cXVnc2tXSlZFR1pFVE4vOERWMytjY09GU3M9Iiwid2l0bmVzc2VzIjpbXX0=","sender":"xjHAz+d0udy1XfHp5qugskWJVEGZETN/8DV3+ccOFSs=","signature":"l3KSuJY7pcNAkfKAff29F9U0TYXCEXuBf6YguWneInaKy8/xK722b9YbvePin0eIPU6fjMp2EUp68Zujun+yDg==","message_id":"UMR7xZHjSsExzgve9U3XxU9VVSdNrcCNWZBolkrwiSs=","witness_signatures":[]}},"id":-1}`;

export const mockEventName = 'Random Name';
export const mockLocation = 'EPFL';
export const mockCreationTime = 1609455600;
export const mockStartTime = 1735685990;
export const mockEndTime = 1735686000;
export const mockRollCallId = 100;

/*
//jest.mock('../../websockets/WebsocketApi.ts');
const mockedPublish = msApi.publish as jest.MockedFunction<typeof msApi.publish>;
*/

export function mockFunction<T extends (...args: any[]) => any>(fn: T): jest.MockedFunction<T> {
  return fn as jest.MockedFunction<T>;
}




// FIXME EBAUCHE
const checkRequests = (channel: Channel, obj: MessageData) => {

  const _descriptionStart = 'the query\'s decoded data';
  const _defaultDataFields = ['object', 'action'];

  const _arrayToString = (arr: string[]) => {
    let res = '';
    arr.forEach((e) => res += (e + ','));
    return `[${res.slice(0, -1)}]`;
  };

  const checkIsBase64String = (str: Base64Data): boolean => {
    try { b64.decode(str.toString()); } catch (error) { return false; }
    return true;
  };

  const checkArrayIsBase64 = (arr: Base64Data[]) => {
    const pubKeyLen = mockPublicKey.length;
    if (!Array.isArray(arr)) return false;

    const res = arr.filter(item => (!checkIsBase64String(item) || item.length !== pubKeyLen));
    return (res.length === 0);
  };

  //console.log(data);

  switch (obj.object) {
    case ObjectType.LAO:

      if (obj.action === ActionType.CREATE) {
        const data: CreateLao = obj as CreateLao;

        assertChai.isObject(data, `${_descriptionStart} should be a JSON object but is a ${typeof data}`);
        const expectedFields = _defaultDataFields.concat(['id', 'name', 'creation', 'organizer', 'witnesses']);
        assertChai.hasAllKeys(
          data,
          expectedFields,
          `${_descriptionStart} fields contains unknown/is missing some fields. Expected : ${_arrayToString(expectedFields)}`
        );

        assertChai.isString(data.id, `${_descriptionStart} id field should be a string. Actual : ${typeof data.id}`);
        assertChai.isTrue(checkIsBase64String(data.id), `${_descriptionStart} id field should be base64 encoded. Actual : ${data.id}`);

        assertChai.isString(data.name, `${_descriptionStart} name field should be a string. Actual : ${typeof data.name}`);
        assertChai.strictEqual(data.name, mockEventName);

        assertChai.isNumber(data.creation);
        assertChai.isAbove(data.creation, 0, `${_descriptionStart} creation field should be greater than 0 but is ${data.creation}`);

        assertChai.isString(data.organizer);
        assertChai.isTrue(checkIsBase64String(data.organizer), `${_descriptionStart} organizer field should be base64 encoded. Actual : ${data.organizer}`);
        assertChai.strictEqual(data.organizer, KeyPairStore.getPublicKey(), `${_descriptionStart} organizer field should correspond to the public key that created the request`);

        assertChai.isArray(data.witnesses);
        assertChai.isTrue(checkArrayIsBase64(data.witnesses), `${_descriptionStart} witnesses field should be an array of base64 strings with correct length (key length = ${mockPublicKey.length})`);
        assertChai.strictEqual(data.witnesses.length, [...new Set(data.witnesses)].length, `${_descriptionStart} witnesses field array should only contain distinct values`);

        // check id
        const expected: Hash = Hash.fromStringArray(data.organizer.toString(), data.creation.toString(), data.name);
        assertChai.strictEqual(data.id.toString(), expected.toString(), `${_descriptionStart} id field "${data.id}" should be "${expected}"`);






      /*else if (msgData.action === ActionType.UPDATE_PROPERTIES) {
        //checkTypicalRequest(request);
        jsonChecker.checkQueryDataUpdateLao(request, object, action);
      } else if (msgData.action === ActionType.STATE) {
        //checkTypicalRequest(request);
        jsonChecker.checkQueryDataStateLao(request, object, action);
      }*/}
      break;
/*
    case ObjectType.MEETING:
      checkTypicalRequest(request);
      jsonChecker.checkQueryDataMeeting(request, object, action);
      break;

    case ObjectType.ROLL_CALL:
      checkTypicalRequest(request);
      jsonChecker.checkQueryDataRollCall(request, object, action);
      break;

    case ObjectType.MESSAGE:
      // isRoot depends of the request
      checkTypicalRequest(request, 'publish', true);
      jsonChecker.checkQueryEmptyWitnessSignature(request);
      jsonChecker.checkQueryDataWitnessMessage(request, object, action);
      break;
*/
    default:
      const a = 2;
      //console.log('unimplemented (in test/websocket/WebsocketApi.ts) : case (default)');
  }

};


// mock sendRequestToServer in order to not send any query but rather check the correctness of said query
//jest.mock('../../websockets/WebsocketApi.ts');
jest.mock('../../websockets/WebsocketApi.ts');
//const publishMock = msApi.publish as jest.MockedFunction<(channel: any, msgData: any) => void>;
const publishMock = mockFunction(wsApi.publish);
publishMock.mockImplementation((channel: Channel, msgData: MessageData) => checkRequests(channel, msgData));



/*
jest.mock('../../websockets/WebsocketApi.ts', () => {

  return {
    ...jest.requireActual('../../websockets/WebsocketApi.ts'),
    publish: jest.fn((c, a) => checkRequests()),
  };
});*/

/*
const checkTypicalRequest = (request, methodExpected = 'publish', isRoot = false) => {
  jsonChecker.checkQueryOuterLayer(request);
  jsonChecker.checkQueryMethod(request, methodExpected);
  jsonChecker.checkParams(request.params, isRoot);
  jsonChecker.checkMessage(request.params.message);
};
*/


describe('=== WebsocketApi tests ===', function() {

  beforeAll(() => {
    initialise();

    const org: PublicKey = KeyPairStore.getPublicKey();
    const time: Timestamp = getCurrentTime();
    const name: string = 'Pop\'s LAO';
    const sampleLao: Lao = new Lao({
      name,
      id: Hash.fromStringArray(org.toString(), time.toString(), name),
      creation: time,
      last_modified: time,
      organizer: org,
      witnesses: [],
    });

    OpenedLaoStore.store(sampleLao);
  });


  /* NOTE: checks are done in checkRequests since msApi.request* return void */

  describe('websockets.WebsocketApi', function () {

    it('should create the correct request for requestCreateLao', function () {
      msApi.requestCreateLao(mockEventName);
    });

    it('should create the correct request for requestUpdateLao', function () {
      msApi.requestUpdateLao(mockEventName);
    });

    it('should create the correct request for requestStateLao', function () {
      msApi.requestStateLao();
    });

    it('should create the correct request for requestCreateMeeting', function () {
      const mockExtra = { numberParticipants: 12, minAge: 18 };
      msApi.requestCreateMeeting(mockEventName, mockStartTime);
      msApi.requestCreateMeeting(mockEventName, mockStartTime, mockLocation);
      msApi.requestCreateMeeting(mockEventName, mockStartTime, mockLocation, mockEndTime);
      msApi.requestCreateMeeting(mockEventName, mockStartTime, mockLocation, mockEndTime, mockExtra);
    });
/*
    it('should create the correct request for requestStateMeeting', function () {
      msApi.requestStateMeeting(mockStartTime);
    });
*/
    it('should create the correct request for requestWitnessMessage', function () {
      msApi.requestWitnessMessage('/root', Base64Data.encode('randomMessageId'));
    });

    it('should create the correct request for requestCreateRollCall', function () {
      const mockScheduledTime = mockStartTime + 1;
      const mockDescription = 'random description';
      msApi.requestCreateRollCall(mockEventName, mockLocation, mockStartTime);
      msApi.requestCreateRollCall(mockEventName, mockLocation, undefined, mockScheduledTime);
      msApi.requestCreateRollCall(mockEventName, mockLocation, mockStartTime, undefined, mockDescription);
      msApi.requestCreateRollCall(mockEventName, mockLocation, undefined, mockScheduledTime, mockDescription);
    });
/*
    it('should create the correct request for requestOpenRollCall', function () {
      msApi.requestOpenRollCall(mockRollCallId);
      msApi.requestOpenRollCall(mockRollCallId, mockStartTime);
    });

    it('should create the correct request for requestReopenRollCall', function () {
      msApi.requestReopenRollCall(mockRollCallId);
      msApi.requestReopenRollCall(mockRollCallId, mockStartTime);
    });

    it('should create the correct request for requestCloseRollCall', function () {
      msApi.requestCloseRollCall(mockRollCallId, []);
      msApi.requestCloseRollCall(mockRollCallId, [
        "xjHAz+d0udy1XfHp5qugskWJVEGZETN/8DV3+ccOFSs=",
        "mK0eAXHPPlxySr1erjOhZNlKz34/+nJ1hi1Sph66fas="
      ]);
    });*/
  });

});
