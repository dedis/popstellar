/* eslint-disable */

import * as msApi from 'network/MessageApi';
import * as wsApi from 'network/WebsocketApi';
import { getCurrentTime } from 'network/WebsocketUtils';
import { storeInit } from 'store/Storage';
import { KeyPairStore, OpenedLaoStore } from 'store';
import { Base64Data, Hash, Lao, PublicKey, Timestamp, WitnessSignature } from 'model/objects';
import {
  ActionType, CloseRollCall,
  CreateLao, CreateMeeting, CreateRollCall,
  MessageData,
  ObjectType, OpenRollCall,
  StateLao, StateMeeting,
  UpdateLao, WitnessMessage
} from 'model/network/method/message/data';
import { Channel } from 'model/objects/Channel';
import * as b64 from 'base-64';

const assertChai = require('chai').assert;


export function mockFunction<T extends (...args: any[]) => any>(fn: T): jest.MockedFunction<T> {
  return fn as jest.MockedFunction<T>;
}

jest.mock('network/WebsocketApi.ts');
const publishMock = mockFunction(wsApi.publish);

// @ts-ignore
publishMock.mockImplementation((channel: Channel, msgData: MessageData) => checkRequests(channel, msgData));



// real set of keys generated by tweetnacl
export const mockPublicKey = 'xjHAz+d0udy1XfHp5qugskWJVEGZETN/8DV3+ccOFSs=';
export const mockSecretKey = 'vx0b2hbxwPBQzfPu9NdlCcYmuFjhUFuIUDx6doHRCM7GMcDP53S53LVd8enmq6CyRYlUQZkRM3/wNXf5xw4VKw==';
export const mockCurrentLao = JSON.parse(`{"jsonrpc":"2.0","method":"publish","params":{"channel":"/root","message":{"data":{"object":"lao","action":"create","id":"4T3gIfBzQINCW8mc1dVtrnfNnawgJxVhrJn8BXqsEG4=","name":"sas","creation":1610730679,"organizer":"xjHAz+d0udy1XfHp5qugskWJVEGZETN/8DV3+ccOFSs=","witnesses":[]},"sender":"xjHAz+d0udy1XfHp5qugskWJVEGZETN/8DV3+ccOFSs=","signature":"7iW6kKwguoSRFo/DB37DusfOG0srcjErte4wKQnS3PHCupcYb9bQXPmOEzKNs6/Q2SqJcNqmqE6hbLGRqTezBw==","message_id":"8/Wg+RGcbDEZwH+PHPHOpcKCyhVgD+MaRj7D/KwVwPo=","witness_signatures":[]}},"id":1}`);
export const sampleCreateLaoQuery = `{"jsonrpc":"2.0","method":"publish","params":{"channel":"/root","message":{"data":"eyJvYmplY3QiOiJsYW8iLCJhY3Rpb24iOiJjcmVhdGUiLCJpZCI6InI2bWRsOWxYd2RycytZbXovQWY4M2NPVXpXMU00RTJMMm82LzdRTUdRazQ9IiwibmFtZSI6Im15IGxpbCcgTEFPIDopIiwiY3JlYXRpb24iOjE2MTA3NjI3NDcsIm9yZ2FuaXplciI6InhqSEF6K2QwdWR5MVhmSHA1cXVnc2tXSlZFR1pFVE4vOERWMytjY09GU3M9Iiwid2l0bmVzc2VzIjpbXX0=","sender":"xjHAz+d0udy1XfHp5qugskWJVEGZETN/8DV3+ccOFSs=","signature":"l3KSuJY7pcNAkfKAff29F9U0TYXCEXuBf6YguWneInaKy8/xK722b9YbvePin0eIPU6fjMp2EUp68Zujun+yDg==","message_id":"UMR7xZHjSsExzgve9U3XxU9VVSdNrcCNWZBolkrwiSs=","witness_signatures":[]}},"id":-1}`;

export const mockEventName = 'Random Name';
export const mockLocation = 'EPFL';
export const mockCreationTime = 1609455600;
export const mockStartTime = 1735685990;
export const mockEndTime = 1735686000;
export const mockRollCallId = 100;

const _descriptionStart = 'the query\'s decoded data';
const _defaultDataFields = ['object', 'action'];

const _arrayToString = (arr: string[]) => {
  let res = '';
  arr.forEach((e) => res += (e + ','));
  return `[${res.slice(0, -1)}]`;
};

const checkIsBase64String = (str: Base64Data): boolean => {
  try { b64.decode(str.toString()); } catch (error) { return false; }
  return true;
};

const checkArrayIsBase64 = (arr: Base64Data[]) => {
  const pubKeyLen = mockPublicKey.length;
  if (!Array.isArray(arr)) return false;

  const res = arr.filter(item => (!checkIsBase64String(item) || item.length !== pubKeyLen));
  return (res.length === 0);
};

const checkArrayKeySignPairIsBase64 = (arr: WitnessSignature[]) => {
  const pubKeyLen = mockPublicKey.length;
  if (!Array.isArray(arr)) return false;

  arr.forEach((item) => {
    if (typeof item !== 'object' || Object.keys(item).length !== 2) return false;
    if (!(
      Object.prototype.hasOwnProperty.call(item, 'witness')
      && Object.prototype.hasOwnProperty.call(item, 'signature')
    )) return false;

    if (!checkIsBase64String(item.witness) || !checkIsBase64String(item.signature)) return false;
    if (item.witness.length !== pubKeyLen) return false;
    // not checked : signature correctness
  });
  return true;
};



const checkRequests = (channel: Channel, obj: MessageData) => {
  switch (obj.object) {

    case ObjectType.LAO:
      switch (obj.action) {
        case ActionType.CREATE:
          checkDataCreateLao(obj);
          break;
        case ActionType.UPDATE_PROPERTIES:
          checkDataUpdateLao(obj);
          break;
        case ActionType.STATE:
          checkDataStateLao(obj);
          break;
        default:
          assertChai.fail(`Unknown action '${obj.action}'`);
      }
      break;


    case ObjectType.MEETING:
      switch (obj.action) {
        case ActionType.CREATE:
          checkDataCreateMeeting(obj);
          break;
        case ActionType.STATE:
          checkDataStateMeeting(obj);
          break;
        default:
          assertChai.fail(`Unknown action '${obj.action}'`);
      }
      break;


    case ObjectType.ROLL_CALL:
      switch (obj.action) {
        case ActionType.CREATE:
          checkDataCreateRollCall(obj);
          break;
        case ActionType.OPEN:
          checkDataOpenRollCall(obj);
          break;
        case ActionType.REOPEN:
          checkDataReopenRollCall(obj);
          break;
        case ActionType.CLOSE:
          checkDataCloseRollCall(obj);
          break;
        default:
          assertChai.fail(`Unknown action '${obj.action}'`);
      }
      break;


    case ObjectType.MESSAGE:
      switch (obj.action) {
        case ActionType.WITNESS:
          checkDataWitnessMessage(obj);
          break;
        default:
          assertChai.fail(`Unknown action '${obj.action}'`);
      }
      // isRoot depends of the request
      break;

    default:
      assertChai.fail(`Unknown object '${obj.object}'`);
  }
};

describe('=== WebsocketApi tests ===', function() {

  beforeAll(() => {
    storeInit();

    const org: PublicKey = KeyPairStore.getPublicKey();
    const time: Timestamp = getCurrentTime();
    const name: string = 'Pop\'s LAO';
    const sampleLao: Lao = new Lao({
      name,
      id: Hash.fromStringArray(org.toString(), time.toString(), name),
      creation: time,
      last_modified: time,
      organizer: org,
      witnesses: [],
    });

    OpenedLaoStore.store(sampleLao);
  });


  /* NOTE: checks are done in checkRequests since msApi.request* return void */

  describe('network.WebsocketApi', function () {

    it('should create the correct request for requestCreateLao', function () {
      msApi.requestCreateLao(mockEventName);
    });

    it('should create the correct request for requestUpdateLao', function () {
      msApi.requestUpdateLao(mockEventName);
    });

    it('should create the correct request for requestStateLao', function () {
      msApi.requestStateLao();
    });

    it('should create the correct request for requestCreateMeeting', function () {
      const mockExtra = { numberParticipants: 12, minAge: 18 };
      msApi.requestCreateMeeting(mockEventName, mockStartTime);
      msApi.requestCreateMeeting(mockEventName, mockStartTime, mockLocation);
      msApi.requestCreateMeeting(mockEventName, mockStartTime, mockLocation, mockEndTime);
      msApi.requestCreateMeeting(mockEventName, mockStartTime, mockLocation, mockEndTime, mockExtra);
    });
/*
    it('should create the correct request for requestStateMeeting', function () {
      msApi.requestStateMeeting(mockStartTime);
    });
*/
    it('should create the correct request for requestWitnessMessage', function () {
      msApi.requestWitnessMessage('/root', Base64Data.encode('randomMessageId'));
    });

    it('should create the correct request for requestCreateRollCall', function () {
      const mockScheduledTime = mockStartTime + 1;
      const mockDescription = 'random description';
      msApi.requestCreateRollCall(mockEventName, mockLocation, mockStartTime);
      msApi.requestCreateRollCall(mockEventName, mockLocation, undefined, mockScheduledTime);
      msApi.requestCreateRollCall(mockEventName, mockLocation, mockStartTime, undefined, mockDescription);
      msApi.requestCreateRollCall(mockEventName, mockLocation, undefined, mockScheduledTime, mockDescription);
    });
/*
    it('should create the correct request for requestOpenRollCall', function () {
      msApi.requestOpenRollCall(mockRollCallId);
      msApi.requestOpenRollCall(mockRollCallId, mockStartTime);
    });

    it('should create the correct request for requestReopenRollCall', function () {
      msApi.requestReopenRollCall(mockRollCallId);
      msApi.requestReopenRollCall(mockRollCallId, mockStartTime);
    });

    it('should create the correct request for requestCloseRollCall', function () {
      msApi.requestCloseRollCall(mockRollCallId, []);
      msApi.requestCloseRollCall(mockRollCallId, [
        "xjHAz+d0udy1XfHp5qugskWJVEGZETN/8DV3+ccOFSs=",
        "mK0eAXHPPlxySr1erjOhZNlKz34/+nJ1hi1Sph66fas="
      ]);
    });*/
  });

});

function checkDataCreateLao(obj: MessageData) {
  const data: CreateLao = obj as CreateLao;

  assertChai.isObject(data, `${_descriptionStart} should be a JSON object but is a ${typeof data}`);
  const expectedFields = _defaultDataFields.concat(['id', 'name', 'creation', 'organizer', 'witnesses']);
  assertChai.hasAllKeys(
    data,
    expectedFields,
    `${_descriptionStart} fields contains unknown/is missing some fields. Expected : ${_arrayToString(expectedFields)}`
  );

  assertChai.isString(data.id, `${_descriptionStart} id field should be a string. Actual : ${typeof data.id}`);
  assertChai.isTrue(checkIsBase64String(data.id), `${_descriptionStart} id field should be base64 encoded. Actual : ${data.id}`);

  assertChai.isString(data.name, `${_descriptionStart} name field should be a string. Actual : ${typeof data.name}`);
  assertChai.strictEqual(data.name, mockEventName);

  assertChai.isNumber(data.creation);
  assertChai.isAbove(data.creation, 0, `${_descriptionStart} creation field should be greater than 0 but is ${data.creation}`);

  assertChai.isString(data.organizer);
  assertChai.isTrue(checkIsBase64String(data.organizer), `${_descriptionStart} organizer field should be base64 encoded. Actual : ${data.organizer}`);
  assertChai.strictEqual(data.organizer, KeyPairStore.getPublicKey(), `${_descriptionStart} organizer field should correspond to the public key that created the request`);

  assertChai.isArray(data.witnesses);
  assertChai.isTrue(checkArrayIsBase64(data.witnesses), `${_descriptionStart} witnesses field should be an array of base64 strings with correct length (key length = ${mockPublicKey.length})`);
  assertChai.strictEqual(data.witnesses.length, [...new Set(data.witnesses)].length, `${_descriptionStart} witnesses field array should only contain distinct values`);

  // check id
  const expected: Hash = Hash.fromStringArray(data.organizer.toString(), data.creation.toString(), data.name);
  assertChai.strictEqual(data.id.toString(), expected.toString(), `${_descriptionStart} id field "${data.id}" should be "${expected}"`);
}

function checkDataUpdateLao(obj: MessageData) {
  const data: UpdateLao = obj as UpdateLao;

  assertChai.isObject(data, `${_descriptionStart} should be a JSON object but is a ${typeof data}`);
  const expectedFields = _defaultDataFields.concat(['id', 'name', 'last_modified', 'witnesses']);
  assertChai.hasAllKeys(
    data,
    expectedFields,
    `${_descriptionStart} fields contains unknown/is missing some fields. Expected : ${_arrayToString(expectedFields)}`
  );

  assertChai.isString(data.id, `${_descriptionStart} id field should be a string. Actual : ${typeof data.id}`);
  assertChai.isTrue(checkIsBase64String(data.id), `${_descriptionStart} id field should be base64 encoded. Actual : ${data.id}`);

  assertChai.isString(data.name, `${_descriptionStart} name field should be a string. Actual : ${typeof data.name}`);
  assertChai.strictEqual(data.name, mockEventName);

  assertChai.isNumber(data.last_modified);
  assertChai.isAbove(data.last_modified, 0, `${_descriptionStart} last_modified field should be greater than 0 but is ${data.last_modified}`);

  assertChai.isArray(data.witnesses);
  assertChai.isTrue(checkArrayIsBase64(data.witnesses), `${_descriptionStart} witnesses field should be an array of base64 strings with correct length (key length = ${mockPublicKey.length})`);
  assertChai.strictEqual(data.witnesses.length, [...new Set(data.witnesses)].length, `${_descriptionStart} witnesses field array should only contain distinct values`);

  // check id
  const expected = Hash.fromStringArray(
    OpenedLaoStore.get().organizer.toString(),
    OpenedLaoStore.get().creation.toString(),
    data.name
  );
  assertChai.deepEqual(data.id, expected, `${_descriptionStart} id field "${data.id}" should be "${expected}"`);
}

function checkDataStateLao(obj: MessageData) {
  const data: StateLao = obj as StateLao;

  assertChai.isObject(data, `${_descriptionStart} should be a JSON object but is a ${typeof data}`);
  const expectedFields = _defaultDataFields.concat(['id', 'name', 'creation', 'last_modified', 'organizer', 'witnesses', 'modification_id', 'modification_signatures']);
  assertChai.hasAllKeys(
    data,
    expectedFields,
    `${_descriptionStart} fields contains unknown/is missing some fields. Expected : ${_arrayToString(expectedFields)}`
  );

  assertChai.isString(data.id, `${_descriptionStart} id field should be a string. Actual : ${typeof data.id}`);
  assertChai.isTrue(checkIsBase64String(data.id), `${_descriptionStart} id field should be base64 encoded. Actual : ${data.id}`);

  assertChai.isString(data.name, `${_descriptionStart} name field should be a string. Actual : ${typeof data.name}`);
  assertChai.strictEqual(data.name, OpenedLaoStore.get().name);

  assertChai.isNumber(data.creation);
  assertChai.isAbove(data.creation, 0, `${_descriptionStart} creation field should be greater than 0 but is ${data.creation}`);

  assertChai.isNumber(data.last_modified);
  assertChai.isAbove(data.last_modified, 0, `${_descriptionStart} last_modified field should be greater than 0 but is ${data.last_modified}`);
  assertChai.isAbove(data.last_modified.valueOf() + 1, data.creation, `${_descriptionStart} last_modified field should be greater than creation (${data.creation}) but is ${data.last_modified}`);

  assertChai.isString(data.organizer);
  assertChai.isTrue(checkIsBase64String(data.organizer), `${_descriptionStart} organizer field should be base64 encoded. Actual : ${data.organizer}`);
  assertChai.deepEqual(data.organizer, OpenedLaoStore.get().organizer, `${_descriptionStart} organizer field should correspond to the public key that created the request`);

  assertChai.isArray(data.witnesses);
  assertChai.isTrue(checkArrayIsBase64(data.witnesses), `${_descriptionStart} witnesses field should be an array of base64 strings with correct length (key length = ${mockPublicKey.length})`);
  assertChai.strictEqual(data.witnesses.length, [...new Set(data.witnesses)].length, `${_descriptionStart} witnesses field array should only contain distinct values`);

  assertChai.isString(data.modification_id);
  assertChai.isTrue(checkIsBase64String(data.modification_id), `${_descriptionStart} modification_id field should be base64 encoded. Actual : ${data.modification_id}`);

  assertChai.isArray(data.modification_signatures);
  assertChai.isTrue(checkArrayKeySignPairIsBase64(data.modification_signatures), `${_descriptionStart} modification_signatures field should contain base64 encoded key sign pairs. Actual : ${data.modification_signatures}`);

  // check id
  const expected = Hash.fromStringArray(data.organizer.toString(), OpenedLaoStore.get().creation.toString(), data.name);
  assertChai.deepEqual(data.id, expected, `${_descriptionStart} id field "${data.id}" should be "${expected}"`);
}

function checkDataCreateMeeting(obj: MessageData) {
  const data: CreateMeeting = obj as CreateMeeting;

  assertChai.isObject(data, `${_descriptionStart} should be a JSON object but is a ${typeof data}`);
  const expectedMinFields = _defaultDataFields.concat(['id', 'name', 'creation', 'start']);
  const optionalFields = ['location', 'end', 'extra'];
  const possibleFields = expectedMinFields.concat(optionalFields);
  assertChai.containsAllKeys(
    data,
    expectedMinFields,
    `${_descriptionStart} fields are missing essential fields. Expected : ${_arrayToString(expectedMinFields)}`
  );
  const isSubsetOfPossibleFields = Object.getOwnPropertyNames(data).every(field => possibleFields.includes(field));
  assertChai.isTrue(isSubsetOfPossibleFields, `${_descriptionStart} contains additional unknown fields. Possible fields : ${_arrayToString(possibleFields)}, Actual fields : ${_arrayToString(Object.getOwnPropertyNames(data))}`);

  assertChai.isString(data.id, `${_descriptionStart} id field should be a string. Actual : ${typeof data.id}`);
  assertChai.isTrue(checkIsBase64String(data.id), `${_descriptionStart} id field should be base64 encoded. Actual : ${data.id}`);

  assertChai.isString(data.name, `${_descriptionStart} name field should be a string. Actual : ${typeof data.name}`);
  assertChai.strictEqual(data.name, mockEventName);

  assertChai.isNumber(data.creation);
  assertChai.isAbove(data.creation, 0, `${_descriptionStart} creation field should be greater than 0 but is ${data.creation}`);

  if (Object.prototype.hasOwnProperty.call(data, 'location')) {
    assertChai.isString(data.location, `${_descriptionStart} location field should be a string. Actual : ${typeof data.location}`);
    assertChai.strictEqual(data.location, mockLocation);
  }

  assertChai.isNumber(data.start);
  assertChai.isAbove(data.start, 0, `${_descriptionStart} start field should be greater than 0 but is ${data.start}`);
  //assertChai.isAbove(data.start + 1, data.creation, `${_descriptionStart} start field should be greater than or equal to creation (${data.creation}) but is ${data.start}`);

  if (Object.prototype.hasOwnProperty.call(data, 'end')) {
    assertChai.isNumber(data.end);
    assertChai.isAbove(data.end, 0, `${_descriptionStart} end field should be greater than 0 but is ${data.end}`);
    // @ts-ignore
    assertChai.isAbove(data.end.valueOf() + 1, data.start, `${_descriptionStart} end field should be greater than or equal to start (${data.start}) but is ${data.end}`);
  }

  if (Object.prototype.hasOwnProperty.call(data, 'extra')) {
    assertChai.isObject(data.extra);
  }

  // check id
  const expected = Hash.fromStringArray('M', OpenedLaoStore.get().id.toString(), OpenedLaoStore.get().creation.toString(), data.name);
  assertChai.deepEqual(data.id, expected, `${_descriptionStart} id field "${data.id}" should be "${expected}"`);
}

function checkDataStateMeeting(obj: MessageData) {
  assertChai.fail('adapt old tests below once msApi is able to send these messages');
  /*
  const data: StateMeeting = obj as StateMeeting;

  assertChai.isObject(data, `${_descriptionStart} should be a JSON object but is a ${typeof data}`);
  const expectedMinFields = _defaultDataFields.concat(["id", "name", "creation", "last_modified", "start", "modification_id", "modification_signatures"]);
  const optionalFields = ['location', 'end', 'extra'];
  const possibleFields = expectedMinFields.concat(optionalFields);
  assertChai.containsAllKeys(
    data,
    expectedMinFields,
    `${_descriptionStart} fields are missing essential fields. Expected : ${_arrayToString(expectedMinFields)}`
  );
  const isSubsetOfPossibleFields = Object.getOwnPropertyNames(data).every(field => possibleFields.includes(field));
  assertChai.isTrue(isSubsetOfPossibleFields, `${_descriptionStart} contains additional unknown fields. Possible fields : ${_arrayToString(possibleFields)}, Actual fields : ${_arrayToString(Object.getOwnPropertyNames(data))}`);

  assertChai.isString(data.id, `${_descriptionStart} id field should be a string. Actual : ${typeof data.id}`);
  assertChai.isTrue(checkIsBase64String(data.id), `${_descriptionStart} id field should be base64 encoded. Actual : ${data.id}`);

  assertChai.isString(data.name, `${_descriptionStart} name field should be a string. Actual : ${typeof data.name}`);
  assertChai.strictEqual(data.name, mockCurrentLao.params.message.data.name);

  assertChai.isNumber(data.creation);
  assertChai.isAbove(data.creation, 0, `${_descriptionStart} creation field should be greater than 0 but is ${data.creation}`);

  assertChai.isNumber(data.last_modified);
  assertChai.isAbove(data.last_modified, 0, `${_descriptionStart} last_modified field should be greater than 0 but is ${data.last_modified}`);
  assertChai.isAbove(data.last_modified.valueOf() + 1, data.creation, `${_descriptionStart} last_modified field should be greater than or equal to creation (${data.creation}) but is ${data.last_modified}`);

  if (Object.prototype.hasOwnProperty.call(data, 'location')) {
    assertChai.isString(data.location, `${_descriptionStart} location field should be a string. Actual : ${typeof data.location}`);
    assertChai.strictEqual(data.location, mockLocation);
  }

  assertChai.isNumber(data.start);
  assertChai.isAbove(data.start, 0, `${_descriptionStart} start field should be greater than 0 but is ${data.start}`);
  assertChai.isAbove(data.start.valueOf() + 1, data.creation, `${_descriptionStart} start field should be greater than or equal to creation (${data.creation}) but is ${data.start}`);

  if (Object.prototype.hasOwnProperty.call(data, 'end')) {
    assertChai.isNumber(data.end);
    assertChai.isAbove(data.end, 0, `${_descriptionStart} end field should be greater than 0 but is ${data.end}`);
    // @ts-ignore
    assertChai.isAbove(data.end.valueOf() + 1, data.start, `${_descriptionStart} end field should be greater than or equal to start (${data.start}) but is ${data.end}`);
  }

  if (Object.prototype.hasOwnProperty.call(data, 'extra')) {
    assertChai.isObject(data.extra);
  }

  assertChai.isString(data.modification_id);
  assertChai.isTrue(checkIsBase64String(data.modification_id), `${_descriptionStart} modification_id field should be base64 encoded. Actual : ${data.modification_id}`);

  assertChai.isArray(data.modification_signatures);
  assertChai.isTrue(checkArrayKeySignPairIsBase64(data.modification_signatures), `${_descriptionStart} modification_signatures field should contain base64 encoded key sign pairs. Actual : ${data.modification_signatures}`);

  // check id
  const expected = Hash.fromStringArray('M', OpenedLaoStore.get().id.toString(), OpenedLaoStore.get().creation.toString(), data.name);
  assertChai.deepEqual(data.id, expected, `${_descriptionStart} id field "${data.id}" should be "${expected}"`);
  */
}

function checkDataWitnessMessage(obj: MessageData) {
  const data: WitnessMessage = obj as WitnessMessage;

  assertChai.isObject(data, `${_descriptionStart} should be a JSON object but is a ${typeof data}`);
  const expectedMinFields = _defaultDataFields.concat(['message_id', 'signature']);
  const optionalFields: string[] = [];
  const possibleFields = expectedMinFields.concat(optionalFields);
  assertChai.containsAllKeys(
    data,
    expectedMinFields,
    `${_descriptionStart} fields are missing essential fields. Expected : ${_arrayToString(expectedMinFields)}`
  );
  const isSubsetOfPossibleFields = Object.getOwnPropertyNames(data).every(field => possibleFields.includes(field));
  assertChai.isTrue(isSubsetOfPossibleFields, `${_descriptionStart} contains additional unknown fields. Possible fields : ${_arrayToString(possibleFields)}, Actual fields : ${_arrayToString(Object.getOwnPropertyNames(data))}`);

  assertChai.isString(data.message_id, `${_descriptionStart} id field should be a string. Actual : ${typeof data.message_id}`);
  assertChai.isTrue(checkIsBase64String(data.message_id), `${_descriptionStart} message_id field should be base64 encoded. Actual : ${data.message_id}`);

  assertChai.isString(data.signature, `${_descriptionStart} signature field should be a string. Actual : ${typeof data.signature}`);
  assertChai.isTrue(checkIsBase64String(data.signature), `${_descriptionStart} signature field should be base64 encoded. Actual : ${data.signature}`);
}

function checkDataCreateRollCall(obj: MessageData) {
  const data: CreateRollCall = obj as CreateRollCall;

  assertChai.isObject(data, `${_descriptionStart} should be a JSON object but is a ${typeof data}`);
  const expectedMinFields = _defaultDataFields.concat(['id', 'name', 'creation', 'location']);
  const optionalFields = ['start', 'scheduled', 'roll_call_description'];
  const possibleFields = expectedMinFields.concat(optionalFields);
  assertChai.containsAllKeys(
    data,
    expectedMinFields,
    `${_descriptionStart} fields are missing essential fields. Expected : ${_arrayToString(expectedMinFields)}`
  );
  const xor = (Object.prototype.hasOwnProperty.call(data, 'start') && Object.prototype.hasOwnProperty.call(data, 'scheduled'));
  assertChai.isFalse(xor, 'the create roll call data field contains both a "start" and "scheduled" field');
  const isSubsetOfPossibleFields = Object.getOwnPropertyNames(data).every(field => possibleFields.includes(field));
  assertChai.isTrue(isSubsetOfPossibleFields, `${_descriptionStart} contains additional unknown fields. Possible fields : ${_arrayToString(possibleFields)}, Actual fields : ${_arrayToString(Object.getOwnPropertyNames(data))}`);

  assertChai.isString(data.id, `${_descriptionStart} id field should be a string. Actual : ${typeof data.id}`);
  assertChai.isTrue(checkIsBase64String(data.id), `${_descriptionStart} id field should be base64 encoded. Actual : ${data.id}`);

  assertChai.isString(data.name, `${_descriptionStart} name field should be a string. Actual : ${typeof data.name}`);
  assertChai.strictEqual(data.name, mockEventName);

  assertChai.isNumber(data.creation);
  assertChai.isAbove(data.creation.valueOf(), 0, `${_descriptionStart} creation field should be greater than 0 but is ${data.creation}`);

  if (Object.prototype.hasOwnProperty.call(data, 'start')) {
    assertChai.isNumber(data.start);
    assertChai.isAbove(data.start, 0, `${_descriptionStart} start field should be greater than 0 but is ${data.start}`);
    // @ts-ignore
    assertChai.isAbove(data.start.valueOf() + 1, data.creation, `${_descriptionStart} start field should be greater than or equal to creation (${data.creation}) but is ${data.start}`);
  }

  if (Object.prototype.hasOwnProperty.call(data, 'scheduled')) {
    assertChai.isNumber(data.scheduled);
    assertChai.isAbove(data.scheduled, 0, `${_descriptionStart} scheduled field should be greater than 0 but is ${data.scheduled}`);
    // @ts-ignore
    assertChai.isAbove(data.scheduled.valueOf() + 1, data.creation, `${_descriptionStart} scheduled field should be greater than or equal to creation (${data.creation}) but is ${data.scheduled}`);
  }

  assertChai.isString(data.location, `${_descriptionStart} location field should be a string. Actual : ${typeof data.location}`);
  assertChai.strictEqual(data.location, mockLocation);

  if (Object.prototype.hasOwnProperty.call(data, 'roll_call_description')) {
    assertChai.isString(data.roll_call_description);
  }

  // check id
  const expected = Hash.fromStringArray('R', OpenedLaoStore.get().id.toString(), data.creation.toString(), data.name);
  assertChai.deepEqual(data.id, expected, `${_descriptionStart} id field "${data.id}" should be "${expected}"`);
}

function checkDataOpenRollCall(obj: MessageData) {
  assertChai.fail('adapt old tests below once msApi is able to send these messages');
/*
  const data: OpenRollCall = obj as OpenRollCall;

  assertChai.isObject(data, `${_descriptionStart} should be a JSON object but is a ${typeof data}`);
  const expectedMinFields = _defaultDataFields.concat(['id', 'start']);
  const optionalFields: string[] = [];
  const possibleFields = expectedMinFields.concat(optionalFields);
  assertChai.containsAllKeys(
    data,
    expectedMinFields,
    `${_descriptionStart} fields are missing essential fields. Expected : ${_arrayToString(expectedMinFields)}`
  );
  const isSubsetOfPossibleFields = Object.getOwnPropertyNames(data).every(field => possibleFields.includes(field));
  assertChai.isTrue(isSubsetOfPossibleFields, `${_descriptionStart} contains additional unknown fields. Possible fields : ${_arrayToString(possibleFields)}, Actual fields : ${_arrayToString(Object.getOwnPropertyNames(data))}`);

  assertChai.isString(data.id, `${_descriptionStart} id field should be a string. Actual : ${typeof data.id}`);
  assertChai.isTrue(checkIsBase64String(data.id), `${_descriptionStart} id field should be base64 encoded. Actual : ${data.id}`);

  assertChai.isNumber(data.start);
  assertChai.isAbove(data.start.valueOf(), 0, `${_descriptionStart} start field should be greater than 0 but is ${data.start}`);

  // check id
  const expected = Hash.fromStringArray('R', OpenedLaoStore.get().id.toString(), 444, 'r-cName'); // 444 and r-cName are for now hardocded in the APi
  assertChai.deepEqual(data.id, expected, `${_descriptionStart} id field "${data.id}" should be "${expected}"`);*/
}

function checkDataReopenRollCall(obj: MessageData) {
  assertChai.fail('adapt old tests below once msApi is able to send these messages');
  /*
  const data: ReopenRollCall = obj as ReopenRollCall;

  assertChai.isObject(data, `${_descriptionStart} should be a JSON object but is a ${typeof data}`);
  const expectedMinFields = _defaultDataFields.concat(['id', 'start']);
  const optionalFields: string[] = [];
  const possibleFields = expectedMinFields.concat(optionalFields);
  assertChai.containsAllKeys(
    data,
    expectedMinFields,
    `${_descriptionStart} fields are missing essential fields. Expected : ${_arrayToString(expectedMinFields)}`
  );
  const isSubsetOfPossibleFields = Object.getOwnPropertyNames(data).every(field => possibleFields.includes(field));
  assertChai.isTrue(isSubsetOfPossibleFields, `${_descriptionStart} contains additional unknown fields. Possible fields : ${_arrayToString(possibleFields)}, Actual fields : ${_arrayToString(Object.getOwnPropertyNames(data))}`);

  assertChai.isString(data.id, `${_descriptionStart} id field should be a string. Actual : ${typeof data.id}`);
  assertChai.isTrue(checkIsBase64String(data.id), `${_descriptionStart} id field should be base64 encoded. Actual : ${data.id}`);

  assertChai.isNumber(data.start);
  assertChai.isAbove(data.start.valueOf(), 0, `${_descriptionStart} start field should be greater than 0 but is ${data.start}`);

  // check id
  const expected = Hash.fromStringArray('R', OpenedLaoStorage.get().id.toString(), 444, 'r-cName'); // 444 and r-cName are for now hardocded in the APi
  assertChai.deepEqual(data.id, expected, `${_descriptionStart} id field "${data.id}" should be "${expected}"`);
  */
}

function checkDataCloseRollCall(obj: MessageData) {
  assertChai.fail('adapt old tests below once msApi is able to send these messages');
  /*
  const data: CloseRollCall = obj as CloseRollCall;

  assertChai.isObject(data, `${_descriptionStart} should be a JSON object but is a ${typeof data}`);
  const expectedMinFields = _defaultDataFields.concat(['id', 'start', 'end', 'attendees']);
  const optionalFields: string[] = [];
  const possibleFields = expectedMinFields.concat(optionalFields);
  assertChai.containsAllKeys(
    data,
    expectedMinFields,
    `${_descriptionStart} fields are missing essential fields. Expected : ${_arrayToString(expectedMinFields)}`
  );
  const isSubsetOfPossibleFields = Object.getOwnPropertyNames(data).every(field => possibleFields.includes(field));
  assertChai.isTrue(isSubsetOfPossibleFields, `${_descriptionStart} contains additional unknown fields. Possible fields : ${_arrayToString(possibleFields)}, Actual fields : ${_arrayToString(Object.getOwnPropertyNames(data))}`);

  assertChai.isString(data.id, `${_descriptionStart} id field should be a string. Actual : ${typeof data.id}`);
  assertChai.isTrue(checkIsBase64String(data.id), `${_descriptionStart} id field should be base64 encoded. Actual : ${data.id}`);

  assertChai.isNumber(data.start);
  assertChai.isAbove(data.start, 0, `${_descriptionStart} start field should be greater than 0 but is ${data.start}`);
  assertChai.strictEqual(data.start, 555); // 555 is for now hardcoded in the API

  assertChai.isNumber(data.end);
  assertChai.isAbove(data.end, 0, `${_descriptionStart} end field should be greater than 0 but is ${data.end}`);
  assertChai.isAbove(data.end.valueOf() + 1, data.start, `${_descriptionStart} end field should be greater than or equal to start (${data.start}) but is ${data.end}`);

  assertChai.isArray(data.attendees);
  assertChai.isTrue(checkArrayIsBase64(data.attendees), `${_descriptionStart} attendees field should be an array of base64 strings with correct length (key length = ${mockPublicKey.length})`);
  assertChai.strictEqual(data.attendees.length, [...new Set(data.attendees)].length, `${_descriptionStart} attendees field array should only contain distinct values`);

  // check id
  const expected = Hash.fromStringArray('R', OpenedLaoStore.get().id.toString(), 444, 'r-cName'); // 444 and r-cName are for now hardocded in the APi
  assertChai.deepEqual(data.id, expected, `${_descriptionStart} id field "${data.id}" should be "${expected}"`);
  */
}
